"""a python version of meltan/core/examples/simple/simple.cc."""

import sys
import google3

from absl import app

from google3.google.protobuf import struct_pb2
from google3.net.proto2.python.public import json_format
from google3.third_party.meltan.core.examples.simple import params_pb2
from google3.third_party.meltan.lib.params import utils
from google3.third_party.meltan.lib.results import results_pb2
from google3.third_party.meltan.lib.results.python import results
from google3.third_party.pybind11_abseil import status as error
# copybara:strip_begin(not yet open-sourced)
from google3.net.proto2.python.public import text_format
from google3.third_party.meltan.core.hwinterface import cpu_pb2
from google3.third_party.meltan.core.hwinterface import service_pb2
from google3.third_party.meltan.core.hwinterface.client.python import service_client
# copybara:strip_end


def main(argv) -> None:  # pylint: disable=unused-argument
  try:
    runner = results.InitTestRun("myTest")
  except error.StatusNotOk as e:
    print("Init Test Run Failed %s " % e, file=sys.stderr)
    return

  runner.LogInfo("Initialized the test!")

  # Parse the input parameters.
  try:
    params = utils.GetParams(params_pb2.Params())  # pylint: disable=unused-variable
  except json_format.ParseError as e:
    runner.AddError("my_test-procedural-error",
                    "Failed to parse parameters:{0}".format(e))
    return

  dut_info = results.DutInfo("TestHost")
  hw_info = results_pb2.HardwareInfo(
      arena="myArena",
      name="myName",
      manufacturer="myManufacturer",
      mfg_part_number="myMfgPartNum",
      part_type="myPartType")

  hw_record = dut_info.AddHardware(hw_info)
  runner.StartAndRegisterInfos([dut_info], params)

  # Make a DutInfo with HW, but forget to register it
  unused_dut_info = results.DutInfo("UnregisteredHost")
  bad_hw_info = results_pb2.HardwareInfo(
      arena="badArena",
      name="badName",
      manufacturer="badManufacturer",
      mfg_part_number="badMfgPartNum",
      part_type="badPartType")
  unregistered_record = unused_dut_info.AddHardware(bad_hw_info)

  try:
    step = results.BeginTestStep(runner, "MyStep")
  except error.StatusNotOk as e:
    runner.AddError("my_test-procedural-error", e)
    return

  # Demonstrate Diagnosis with good/bad HwRecord
  #
  # Adding one registered HwRecord, and one unregistered.
  # This will illustrate that using an unregistered HwRecord
  # emits an Error artifact and the HwRecord will not be
  # referenced in the Diagnosis result
  step.AddDiagnosis(results_pb2.Diagnosis.PASS, "my_test-good-myHardware",
                    "my hardware is good!", [hw_record, unregistered_record])

  # Demonstrate MeasurementSeries
  meas_info = results_pb2.MeasurementInfo(
      name="MySeries", unit="awesomeness 1-10")
  try:
    series = results.BeginMeasurementSeries(step, hw_record, meas_info)
  except error.StatusNotOk as e:
    print(e, file=sys.stderr)
    return

  val_max = struct_pb2.Value(number_value=10)
  val_min = struct_pb2.Value(number_value=0)
  new_range = results_pb2.MeasurementElement.Range(
      maximum=val_max, minimum=val_min)
  series.AddElementWithRange(val_max, new_range)
  series.End()

  meas_info.name = "another series"
  try:
    series = results.BeginMeasurementSeries(step, hw_record, meas_info)
  except error.StatusNotOk as e:
    print(e, file=sys.stderr)
    return

# copybara:strip_begin(not yet open sourced)
  try:
    service_client_step = results.BeginTestStep(runner, "MyServiceClientStep")
  except error.StatusNotOk as e:
    runner.AddError("service_client_step-procedural-error", e)
    return

  try:
    # parse input params to config
    config = service_client.LoadConfig()
  except error.StatusNotOk as e:
    service_client_step.AddError("service_client_step-procedural-error",
                                 "Failed to parse flag: {0}".format(e), [])
    return

  try:
    client = service_client.Create(config)
  except error.StatusNotOk as e:
    service_client_step.AddError(
        "service_client_step-procedural-error",
        "Failed to create service client: {0}".format(e), [])
    return

  cpu_info_req = service_pb2.GetCpuInfoRequest()
  cpu_info_req.info_types.append(cpu_pb2.InfoType.TOPOLOGY)

  try:
    resp = client.GetCpuInfo(cpu_info_req)
  except error.StatusNotOk as e:
    service_client_step.AddError("service_client_step-procedural-error",
                                 "Failed to get cpu info: {0}".format(e), [])
    return

  service_client_step.LogInfo(
      text_format.MessageToString(
          resp,
          as_one_line=True,
      ))

  if resp.info.topology.sockets_enabled > 0:
    service_client_step.AddDiagnosis(results_pb2.Diagnosis.PASS,
                                     "MyServiceClientStep-good-result",
                                     "Result of GetCpuInfo is good!", [])
  else:
    service_client_step.AddDiagnosis(
        results_pb2.Diagnosis.FAIL, "MyServiceClientStep-bad-result",
        "Unable to get cpu info. No CPU sockets detected.", [])
  service_client_step.End()


# copybara:strip_end

if __name__ == "__main__":
  app.run(main)
