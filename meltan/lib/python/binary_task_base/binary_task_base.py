# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Lint as: python3
"""Generic Meltan task base for running a binary.

Provide a framework to run CMD via subprocess, and collect stdout and stderr as
they got generated.

Requires/Takes the following test_info parameters:
* runtime (Required): run time or expect run time
* overhead (Required): process will timeout at runtime+overhead
* filename_stdout: redirect stdout to this file
* filename_stderr: redirect stderr to this file
"""

import subprocess
import threading

from meltan.lib.results.python import results


class GenerateCmdError(Exception):
  """Exception class for errors encountered when generating CMD."""

  def __init__(self, message, symptom):
    super().__init__(message)
    self.message = message
    self.symptom = symptom


class PreExecutionError(Exception):
  """Exception class for errors encountered during PreExecution stage."""

  def __init__(self, message, symptom):
    super().__init__(message)
    self.message = message
    self.symptom = symptom


class BinaryTask:
  """Generic task base for running a binary.

  Attributes:
    step: results.TestStep object
    taskname: The name of this task, as given to __init__.
    binary: The path to the binary to be executed.
    subprocess_kwargs: Custom params to pass to each binary execution.
    sentinel: A sentinel value to use as EOF when reading standard streams.
  """

  def __init__(self,
               step: results.TestStep,
               taskname: str,
               binary: str,
               use_text_mode=False):
    """Initialization.

    Args:
      step: results.TestStep object.
      taskname: Task name.
      binary: Path to the binary to run.
      use_text_mode: If true, then stdout/stderr will be opened in text mode.
        Otherwise binary mode.
    """
    self.step = step
    self.taskname = taskname
    self.binary = binary
    self.subprocess_kwargs = {}
    self.sentinel = "" if use_text_mode else b""
    self._text_mode = use_text_mode
    super().__init__()

  def PreExecution(self, params):
    """Runs before executing the binary.

    Can be used to check platform, setup environment, etc...

    Args:
      params: input parameters.

    Raises:
      PreExecutionError: will send an error diag and terminate early when caught
      in ExecuteTask
    """
    pass

  def GenerateCmd(self, params):
    """Checks inputs and generate CMD to run the binary.

    Args:
      params: input parameters.

    Returns:
      CMD to run the binary

    Raises:
      GenerateCmdError: will send an error diag and terminate early when caught
      in ExecuteTask
    """
    del params
    return [self.binary]

  def PostExecution(self):
    """Runs after executing the binary.

    Can be used to cleanup environment, send pass/fail diags, and .etc.
    """
    pass

  def ProcessStdout(self, stream, f_stdout):
    """Helper method to read stdout stream from subprocess.

    Will log as info, and write to f_stdout.

    Args:
      stream: A stream from a subprocess object.
      f_stdout: file handler to log all stdout.
    """
    for message in iter(stream.readline, self.sentinel):
      f_stdout.write(message)
      message = message if self._text_mode else message.decode("utf-8")
      self.step.LogInfo(message)

  def ProcessStderr(self, stream, f_stderr):
    """Helper method to read stderr stream from subprocess.

    Will log as error or warning, and write to f_stderr.

    Args:
      stream: A stream from a subprocess object.
      f_stderr: file handler to log all stderr.
    """
    for message in iter(stream.readline, self.sentinel):
      f_stderr.write(message)
      message = message if self._text_mode else message.decode("utf-8")
      if message.startswith("WARNING:"):
        self.step.LogWarn(message)
      else:
        self.step.LogError(message)

  def ProcessReturnCode(self, cmd, return_code):
    """Helper method for processing Return Code.

    Args:
      cmd: command used to execute the binary.
      return_code: return code of the binary.
    """
    msg = "Command: {}, Return Code: {}".format(" ".join(cmd), return_code)
    if return_code != 0:
      self.step.LogError(msg)
    else:
      self.step.LogInfo(msg)

  def Exec(self, params):
    """Run the task binary.

    Invokes PreExecution(), runs the command generated by GenerateCmd(),
    consumes stdout/stderr until the process is done, processes the return code
    with ProcessReturnCode() and then runs PostExecution().

    Args:
      params: input params.
    """
    self.step.LogInfo("Executing %s." % self.taskname)

    try:
      self.PreExecution(params)
    except PreExecutionError as e:
      self.step.AddError(e.symptom, e.message, [])
      return

    try:
      cmd = self.GenerateCmd(params)
    except GenerateCmdError as e:
      self.step.AddError(e.symptom, e.message, [])
      return

    runtime = int(params.runtime.ToTimedelta().total_seconds())
    overhead = int(params.overhead.ToTimedelta().total_seconds())

    fn_stdout = params.filename_stdout if hasattr(
        params, "filename_stdout") else "/data/tmp/binary_task_raw.stdout"

    fn_stderr = params.filename_stderr if hasattr(
        params, "filename_stderr") else "/data/tmp/binary_task_raw.stderr"

    mode = "w" if self._text_mode else "wb"

    with open(fn_stdout, mode) as f_stdout, open(fn_stderr, mode) as f_stderr:
      self.step.LogInfo("Running CMD: %s" % " ".join(cmd))
      process = subprocess.Popen(
          cmd,
          stdout=subprocess.PIPE,
          stderr=subprocess.PIPE,
          bufsize=1,
          encoding="utf-8" if self._text_mode else None,
          **self.subprocess_kwargs)
      threads = []
      threads.append(
          threading.Thread(
              target=self.ProcessStdout, args=(process.stdout, f_stdout)))
      threads.append(
          threading.Thread(
              target=self.ProcessStderr, args=(process.stderr, f_stderr)))
      for thread in threads:
        thread.start()
      for thread in threads:
        thread.join()
      try:
        return_code = process.wait(timeout=runtime + overhead)
      except subprocess.TimeoutExpired:  # cpu_check hang
        process.kill()
        message = "{} timeout after {} sec.".format(self.taskname,
                                                    runtime + overhead)
        message += " Runtime set to {} sec.".format(runtime)
        self.step.AddError("{}-timeout".format(self.taskname), message, [])
        return

      self.ProcessReturnCode(cmd, return_code)

    self.PostExecution()
